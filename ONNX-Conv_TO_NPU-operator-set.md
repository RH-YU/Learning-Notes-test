# **ONNX-Conv  TO  NPU-operator-set**

## 背景

`ONNX`中的卷积算子在`NPU`芯片中无法直接进行处理，但是可以转换为`NPU`中支持的算子的组合。`ONNX`中给出的`Conv`算子输入为两个张量，其中`输入张量1`是图像信息，维度为（`N×C×H×W`），`N`是`batch_size`，`C`是`channel`的数量，`H`是图像的高度，`W`是图像的宽度；`输入张量2`为卷积核的信息，维度为（`M×C×KH×KW`），其中`M`代表提取的特征平面的数量（即卷积核的数量），`C`代表`channel`的数量，`KH`是卷积核的高度，`KW`代表卷积核的宽度，一般情况下`KH`和`KW`相等。而`NPU-operator-set`中一般都是对矩阵和向量进行处理，所以需要对`ONNX-Conv`的输入张量进行一定的变换才能适用于`NPU-operator-set`中。

## **转换步骤**

1. 由于`NPU`中支持的算子是矩阵向量乘法以及向量之间的加法，所以需要首先进行对输入的张量进行降维操作。考虑N=1的情况，对于图像信息的`输入张量1`而言，保留图像某一通道的高度`H`和宽度`W`，使其变为2维的图像信息`H×W`；对于卷积核信息的输入张量2而言，保留输入张量1对应通道的卷积核的数量`M`和高度`KH`以及宽度`KW`，使其变为3维的张量`M×KH×KW`。这一步目前不清楚是否可以由`NPU`执行（如果不可以则交给`MCU`执行），暂时定义一个新的算子`dimtransform_1`来执行这个操作。

2. 为了方便运用阵列的矩阵矢量乘法（`VMM`）对卷积操作进行加速，这里需要对降维后的两个输入张量进行变化处理，首先将3维的卷积核张量变为`N`行`M`列的矩阵，其中`N= KH×KW`，`M`为卷积核的数量。然后根据卷积核的大小，计算步长`S`的大小以及是否存在`padding`可将2维的图像信息转换为`K×N`的二维矩阵，其中`P=1`表示存在四周补零的padding，P=0表示不存在padding，`K=[(W-KW+2P)/S+1]*[(H-KH+2P)/S+1]`，`N= KH×KW`。这里可以定义新的算子来执行这个操作。具体操作如下：

   - 对于卷积核的变化可以定义算子为`reshape_1`，主要是将每个`KH×KW`的二维矩阵按照逐行的顺序写成`N×1`的列向量，其中`N=KH×KW`，然后将`M`个二维矩阵变化后形成的`N×1`列向量逐列排步形成`N×M`的矩阵，如下图所示：

     ![](https://github.com/RH-YU/learning_notes_test/raw/master/kernel_transform.png)

   - 对于图像信息的变化可以定义算子为`reshape_2`，主是将二维的图像信息按照卷积核的大小，计算步长S的大小以及是否存在padding进行变换，假设变化之前的二维图像矩阵中的元素可以写为`x(a,b)`

     ，变化之后的二维图像矩阵元素可表示为`x(i,j)`，矩阵中元素第一个元素都记录为`x(1,1)`。

     - 不存在`padding`的变化规律满足以下的等式：

       ![](https://github.com/RH-YU/learning_notes_test/raw/master/formulaf.PNG)
     
     其中`fix(x1,x2)`表示`x1`除以`x2`的商，`mod(x1,x2)`表示`x1`除以`x2`的余数。
     
   - 存在padding的情况即在二维图像矩阵的周围进行补零操作，形成一个新的二维图像矩阵`x'(a,b)`，在新矩阵的基础上变化之后的二维图像矩阵可表示为`x'(i,j)`，且满足以下的规律：
     
     ![](https://github.com/RH-YU/learning_notes_test/raw/master/formulas.PNG)
     
     其中`fix(x1,x2)`表示`x1`除以`x2`的商，`mod(x1,x2)`表示`x1`除以`x2`的余数。
     
     下图给出了`P=0`，`S=1`的变化过程：
     
     ![](https://github.com/RH-YU/learning_notes_test/raw/master/graph_transform.png)

3. 将图片信息和卷积核进行变化之后，需将二维的图片信息变化为1维的输入向量，这里使用算子`dimtransform_1`执行此操作，主要是将`K×N`的矩阵按行划分为`K`个`1×N`的行向量，其中`K=[(W-KW+2P)/S+1]*[(H-KH+2P)/S+1]`。

4. 此后即可使用`VMM`算子进行运算。将图片信息变化后的矩阵的每一行元素可作为`VMM`算子的`N`列输入向量，将卷积核变化后的矩阵作为`VMM`算子的输入矩阵。当图片信息的每一行元素都运算结束后，即可得到`K`个`1×M`的行向量，`M`表示卷积核的数量。该行向量即表示二维图像在每一个卷积核下的输出结果。

5. 上述过程讨论了在一个通道下的转换过程，多个通道情况下可以按照上述步骤得到每个通道下的输出结果，之后需将所有的通道的输出结果（`1×M`行向量）的对应元素相加，此时可使用`NPU`算子`Add In Tile`进行逐行相加再加上偏移量`BIAS`（`1×M`）即可得出K个包含所有通道信息的结果`1×M`行向量。

6. 得出结果后还需`K`个`1×M`行向量进行组合，此处定义算子`reshape_3`执行此操作，主要是将`K`个`1×M`行向量按行组合形成`K×M`的二维矩阵。

7. 得到`K×M`的二维矩阵之后需对矩阵进行升维操作即可得到最终结果，定义算子`dimtransform_2`执行该操作，主要是将`K×M`矩阵的每一列单独写为一个`[(H-KH+2P)/S+1]×[(W-KW+2P)/S+1]`的矩阵，最终的结果可表示为张量的形式`1×M×[(H-KH+2P)/S+1]×[(W-KW+2P)/S+1]`，至此得出了最终的输出张量。

   - 如下图所示，给出了`P=0`，`S=1`的升维过程：

     ![](https://github.com/RH-YU/learning_notes_test/raw/master/dimincrement.png)

## 流程图变化过程

![](https://github.com/RH-YU/learning_notes_test/raw/master/ONNX-NPU.jpg)